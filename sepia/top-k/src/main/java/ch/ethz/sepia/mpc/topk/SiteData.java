// Copyright 2010-2012 Martin Burkhart (martibur@ethz.ch)
//
// This file is part of SEPIA. SEPIA is free software: you can redistribute
// it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.
//
// SEPIA is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with SEPIA.  If not, see <http://www.gnu.org/licenses/>.

package ch.ethz.sepia.mpc.topk;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.logging.Logger;

/**
 * This class reads binary port and full IPv4 distribution files as generated by the BasicMetrics tool.
 * The distribution is stored in a HashMap.
 * @author Martin Burkhart
 */

public class SiteData implements TopKData {
	private static final String FILE_SUBSTRING_PORT = "PORT";
	private static final String FILE_SUBSTRING_IPV4 = "IPV4FULL";
	private static final int DISTRO_SIZE_PORTS = 65536;

	private HashMap<Integer, Integer> distribution;

	private File inputFile;
	private DataInputStream dis;

	/**
	 * @return the inputFile
	 */
	public File getInputFile() {
		return inputFile;
	}

	/**
	 * @param inputFile
	 *            the inputFile to set
	 */
	public void setInputFile(File inputFile) {
		this.inputFile = inputFile;
	}

	/**
	 * Opens the input file.
	 * @throws FileNotFoundException
	 */
	public void openFile() throws FileNotFoundException {
		FileInputStream fis = new FileInputStream(inputFile);
		BufferedInputStream bis = new BufferedInputStream(fis);
		dis = new DataInputStream(bis);
	}

	/**
	 * Closes the input file.
	 * @throws IOException
	 */
	public void closeInputFile() throws IOException {
		dis.close();
		dis = null;
	}

	/**
	 * Reads the next record from the file.
	 * @throws IOException
	 */
	public void readNextTimeslot() throws IOException {
		if (dis == null) {
			openFile();
		}

		if (isPortDistribution()) {
			distribution = new HashMap<Integer, Integer>(DISTRO_SIZE_PORTS);
			dis.readInt(); // Don't need the timestamp
			for (int i = 0; i < DISTRO_SIZE_PORTS; i++) {
				int value = readIntFromLittleEndian(true);
				if (value != 0) {
					distribution.put(i, value); // the index is the key
				}
			}
		} else if (isIPv4Distribution()) {
			// As of now, this assumes a full IP address distribution with <key,
			// value> tuples
			dis.readInt(); // Don't need the timestamp
			int distributionSize = readIntFromLittleEndian(false);
			// System.out.println(getName()+": size of distribution: "+distributionSize);

			distribution = new HashMap<Integer, Integer>(distributionSize);
			for (int i = 0; i < distributionSize; i++) {
				int key = dis.readInt(); // IP is in network byte order (=big
				// endian)
				int value = readIntFromLittleEndian(false);
				if (value != 0) {
					distribution.put(key, value);
					// System.out.println("key="+key+", value="+value);
				}
			}
		} else {
			Logger.getLogger(Logger.GLOBAL_LOGGER_NAME).severe("Input file "+inputFile.getName()+" is not a port or IP address distribution.");
		}
	}

	/**
	 * File is litte endian, we need big endian. Also, to save memory, don't use
	 * long but only int values.
	 */
	private int readIntFromLittleEndian(boolean originalIs64bit)
			throws IOException {
		int value = 0;
		for (int j = 0; j < 4; j++) {
			int b = dis.readUnsignedByte();
			value += b << j * 8;
		}

		if (originalIs64bit) {
			// Values are not expected to be bigger than int, skip the last 4
			// bytes
			int big32bit = dis.readInt();
			if (big32bit != 0) {
				System.err
						.println("A value in the input file is bigger than 32 bits! Results may be wrong.");
			}
		}

		return value;
	}

	/**
	 * Returns true if the distribution is an IPv4 address distribution.
	 * The type of distribution is inferred from the file name.
	 * @return true if the distribution is an IP address distribution
	 */
	public boolean isIPv4Distribution() {
		return inputFile.getName().indexOf(FILE_SUBSTRING_IPV4) > -1;
	}

	/**
	 * Returns true if the distribution is a port distribution.
	 * The type of distribution is inferred from the file name.
	 * @return true if the distribution is a port distribution
	 */
	public boolean isPortDistribution() {
		return inputFile.getName().indexOf(FILE_SUBSTRING_PORT) > -1;
	}

	/**
	 * @return the distribution
	 */
	public HashMap<Integer, Integer> getDistribution() {
		return distribution;
	}
}
